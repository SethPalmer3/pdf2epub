class CharacterConverter:

    def __init__(self, input: str, min_space_threshold: int, max_space_threshold: int) -> None:
        """Takes in the string generated by the image_to_boxes function of
        pytesseract and gives a generator of the Character class
        The space_threshold determines how far apart charactes need to be to insert a space"""
        self.lines = input.split('\n')
        self.current_line = 0
        self.len = len(self.lines)
        self.min_space_threshold = min_space_threshold
        self.max_space_threshold = max_space_threshold
        self.last_converted_char = None


    def __iter__(self):
        return self

    def __len__(self):
        return -1 # Can't know length as spaces are not evaluated
    
    def __next__(self):
        if self.current_line >= self.len:
            raise StopIteration

        spt = self.lines[self.current_line].split(' ')
        while len(spt) < 6:
            self.current_line += 1
            if self.current_line >= self.len:
                raise StopIteration
            spt = self.lines[self.current_line].split(' ')
        character, left, bottom, right, top, page = spt
        if self.last_converted_char != None and \
            self.last_converted_char.character != ' ' and \
            self.max_space_threshold >= int(left) - self.last_converted_char.right_side >= \
            self.min_space_threshold: # Check if the next character needs to be a space
            # print(int(left) - self.last_converted_char.right_side)
            c = Character(' ',\
                          self.last_converted_char.right_side,\
                          int(bottom),\
                          int(left),\
                          int(top),\
                          int(page),\
                          )
        else:
            self.current_line += 1
            c = Character(character, \
                          int(left),\
                          int(bottom),\
                          int(right),\
                          int(top),\
                          int(page)
                          )
        self.last_converted_char = c
        return c


class Character:
    def __init__(self, character: str, left: int, bottom: int, right: int, top: int, page_num: int, *args) -> None:
        self.character = character
        self.left_side = left
        self.bottom_side = bottom
        self.right_side = right
        self.top_side = top
        self.page_num = page_num
        self.width = self.right_side - self.left_side
        self.height = self.top_side - self.bottom_side
        self.data = args

    def vertical_intersection(self, other: "Character") -> bool:
        return self.top_side >= other.top_side >= self.bottom_side or \
                other.top_side >= self.top_side >= other.bottom_side or \
                (self.top_side >= other.top_side and \
                 self.bottom_side <= other.bottom_side) or \
                (other.top_side >= self.top_side and \
                 other.bottom_side <= self.bottom_side) or \
                self.top_side == other.top_side or \
                self.bottom_side == other.bottom_side

    def __str__(self) -> str:
        return f"{self.character} {self.left_side} {self.bottom_side} {self.right_side} {self.top_side}"

    def __repr__(self) -> str:
        return f"{self.character} {self.left_side} {self.bottom_side} {self.right_side} {self.top_side}"

class Line:
    def __init__(self, characters: list[Character], left, bottom, right, top) -> None:
        self.characters = characters
        self.left_side = left
        self.bottom_side = bottom
        self.right_side = right
        self.top_side = top
    def __str__(self) -> str:
        return f"[{self.left_side} {self.bottom_side} {self.right_side} {self.top_side}] " + ' '.join([c.character for c in self.characters])

class LineGenerator:
    def __init__(self, character_generator: CharacterConverter, relative_mode: bool) -> None:
        """
        character_generator: pass a iterator class to pull the characters from
        relative_mode: try testing the next character with the one before it if true
                        or the first character if false
        """
        self.char_gen = character_generator
        self.char_index = 0
        self.relative_mode = relative_mode

    def __iter__(self):
        return self

    def __len__(self):
        return -1 # Cannot know the length until all lines are generated

    def __next__(self):
        character_list: list[Character] = []
        first_char = self.char_gen.__next__()
        heightest_vert_val = first_char.top_side # The relative tallest character of the line (i.e the smallest top_side value)
        lowest_vert_val = first_char.bottom_side # The relative lowest character of the line (i.e the biggest bottom_side value)

        character_list.append(first_char)

        for char in self.char_gen:
            test_against_character = \
                character_list[-1] if self.relative_mode else first_char

            if test_against_character.vertical_intersection(char):
                if char.top_side > heightest_vert_val:
                    heightest_vert_val = char.top_side
                if char.bottom_side < lowest_vert_val:
                    lowest_vert_val = char.bottom_side
                character_list.append(char)
                print(f"{character_list[-1].right_side - character_list[-2].left_side}")
            else:
                break
                
        return Line(character_list, \
                    left=first_char.left_side, \
                    right=character_list[-1].right_side, \
                    top=heightest_vert_val, \
                    bottom=lowest_vert_val
                    )

class Paragraph:
    def __init__(self, lines: list[Line]) -> None:
        self.lines = lines
